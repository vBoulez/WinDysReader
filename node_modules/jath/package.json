{
  "name": "jath",
  "author": {
    "name": "Dan Newcome, @dnewcome"
  },
  "description": "Declarative XML-to-JSON transformation",
  "version": "0.0.3",
  "main": "./jath.js",
  "devDependencies": {
    "libxmljs": "0.8.1"
  },
  "contributors": [
    {
      "name": "Tom Spencer",
      "email": "fiznool@gmail.com"
    },
    {
      "name": "Matthew Robertson"
    }
  ],
  "gitHead": "ed637b98dda03f763346b044b33f17f7bf6ab64c",
  "readme": "# About\r\nJath is a template language that lets you declaratively transform XML documents into\r\nJavascript objects using JSON markup and XPath selectors. The idea is to write\r\nsome JSON markup that looks like the object that you want to end up with, and then\r\nadd XPath selectors to tell Jath where the data should come from.\r\n\r\n# Synopsis\r\n\r\n**Turn:**\r\n\r\n\t<statuses userid=\"djn\">\r\n\t\t<status id=\"1\">\r\n\t\t\t<message>Hello</message>\r\n\t\t</status>\r\n\t\t<status id=\"3\">\r\n\t\t\t<message>Goodbye</message>\r\n\t\t</status>\r\n\t</statuses>\r\n\r\n**into:**\r\n\r\n\t[ \r\n\t\t{ id: \"1\", message: \"Hello\" }, \r\n\t\t{ id: \"3\", message: \"Goodbye\" } \r\n\t]\r\n\r\n**using:**\r\n\r\n\tvar xml = <your AJAXy call here>;\r\n\tvar template = [ \"//status\", { id: \"@id\", message: \"message\" } ];\r\n\tvar result = Jath.parse( template, xml );\r\n\r\nCheck out samples.html for more examples.\r\n\r\n# Example\r\nSay we were parsing an XML stream of status updates from a service\r\nlike Twitter. The data might look something like this:\r\n\r\n\t<statuses userid=\"djn\">\r\n\t\t<status id=\"1\">\r\n\t\t\t<message>Hello</message>\r\n\t\t</status>\r\n\t\t<status id=\"3\">\r\n\t\t\t<message>Goodbye</message>\r\n\t\t</status>\r\n\t\t<status id=\"5\">\r\n\t\t</status>\r\n\t</statuses>\r\n\r\nWe want to consume this data on the client in Javascript. Let's start with\r\na template that will create our status object. We want to have the id and the\r\nmessage as attributes of the object, so we start like this:\r\n\r\n\tvar template = { id: \"\", message: \"\" };\r\n\r\nWhen Jath processes a template, the field names 'id' and 'message' will be used\r\nto hold the data in the resulting Javascript objects. Now that we have described\r\nthe result format, we need to select where the data comes from. This is where\r\nXPath comes in. Relative to the <status> tag, the XPath selector for the id is \r\n\r\n\t@id\r\n\r\nand the selector for the message is simply\r\n\r\n\tmessage\r\n\r\nSo, let's add that to the template:\r\n\r\n\tvar template = { id: \"@id\", message: \"message\" };\r\n\r\nWe could tell Jath to process this template as-is, but to be really useful to us\r\nwe want it to process all of the statuses and return them to us as an array. The\r\narray template form in Jath is an array literal with one small difference: the \r\nfirst element of the array is the XPath selector that returns the collection that\r\nthe array will hold. The second element is the array item template. \r\n\r\nSo to get the statuses in our example we want to use an XPath selector such as\r\n\r\n\t//status\r\n\r\ngiving us a template in the form of \r\n\r\n\tvar template = [ \"//status\", { ... } ];\r\n\r\nWe already know what our item template looks like, so let's insert into the array\r\ntemplate form\r\n\r\n\tvar template = [ \"//status\", { id: \"@id\", message: \"message\" } ];\r\n\r\nProcessing the template looks like this\r\n\r\n\tJath.parse( template, xml )\r\n\r\nwhere xml is an XML document as a Firefox XML DOM object. The resulting Javascript\r\narray, expressed in JSON, would look something like the following\r\n\r\n\tvar result = [ { id: \"1\", message: \"Hello\" }, { id: \"3\", message: \"Goodbye\" }, ... ];\r\n\r\nJath does not support anything other than string data right now, hopefully\r\nthat will change soon.\r\n\r\nLiteral content may be added to the template by prefixing the value with a semicolon. For example:\r\n\r\n    var template [ \"//status\", { id: \"@id\", message: \":literaldata\" } ];\r\n\r\nThe character used to denote literal data can be changed by assigning a different value to:\r\n    \r\n    JSON.literalChar\r\n\r\nOnly a single character may be used to denote a literal.\r\n\r\n## XML Namespaces\r\n\r\nOften more complex XML documents will define [namespaces](http://www.w3.org/TR/REC-xml-names/) to qualify element tag names. When performing Jath queries on namespaced documents you should [implement a namespace resolver](https://developer.mozilla.org/en/Introduction_to_using_XPath_in_JavaScript#Implementing_a_Default_Namespace_Resolver). Once a namespace resolver has been defined it can be set on Jath as follows:\r\n\r\n    Jath.resolver = myResolver\r\n\r\n### Implementing a Namespace Resolver\r\n\r\nThere are two ways to implement XPath namespace resolvers:\r\n\r\n1. write a function that takes a namespace prefix as an argument and returns the namesace uri:\r\n\r\n```javascript\r\n    Jath.resolver = function(prefix) {\r\n    \tif(prefix === \"foo\") {\r\n    \t\treturn \"http://beebop.com/\"\r\n    \t}\r\n    \tif(prefix === \"bar\") {\r\n    \t\treturn \"http://rocksteady.com/\"\r\n    \t}\r\n    }\r\n```\r\n\r\n2. use the `dom.createNSResolver()` method. As an argument this element takes a dom node containing namespace definitions. For example consider the following xml doc:\r\n\r\n```xml\r\n<labels xmlns=\"http://example.com\" xmlns:lbl=\"http://example.com/labelns\">\r\n  <lbl:label id='ep' added=\"2003-06-10\">\r\n    <name>Shredder</name>\r\n    <dimension>X</dimension>\r\n  </lbl:label> \r\n</labels>  \r\n```\r\n\r\nthen the resolver could be defined as follows:\r\n\r\n    Jath.resolver = document.createNSResolver(document.documentElement)\r\n    \r\n### Default Namespaces\r\n\r\nXPath does not tolerate non-null default namespaces. For example:\r\n\r\n```xml\r\n<labels xmlns=\"http://teenage.com\" >\r\n  <label id='ep' added=\"2003-06-10\">\r\n    <name>Shredder</name>\r\n    <dimension>X</dimension>\r\n  </label> \r\n</labels>\r\n```\r\n\r\nOne way to get this working is to manually define a default namespace prefix and write a resolver that returns the default namespace uri in response to it:\r\n\r\n```javascript\r\nJath.resolver = function(prefix) {\r\n  if(prefix === \"dlt\") {\r\n    return \"http://teenage.com\"\r\n  }\r\n}\r\n```\r\n\r\nand then prefix your elements with this default prefix in Jath queries:\r\n\r\n    Jath.parse( {turtle: \"//dlt:name\"}, dom )\r\n\r\n# Status\r\nThis software is still evolving. There are likely cases that it cannot handle, so \r\nfile a feature request in github if there is something you think it should do.\r\n\r\n# Supported environments\r\nJath fully supports Node.js, Firefox, Safari, Chrome and Windows Script Host. IE and Opera are mostly supported.\r\nMore test coverage would help here.\r\n\r\n# Limitations\r\n\r\n- No support for dates or numeric types\r\n\r\n# License\r\nJath is provided under the MIT free software license. See the file LICENSE for \r\nthe full text.\r\n",
  "readmeFilename": "README.md",
  "_id": "jath@0.0.3",
  "_shasum": "2a273566f17f933fc7545b96dd50e9dcd410834d",
  "_from": "danielweck/jath",
  "_resolved": "git://github.com/danielweck/jath.git#ed637b98dda03f763346b044b33f17f7bf6ab64c"
}
